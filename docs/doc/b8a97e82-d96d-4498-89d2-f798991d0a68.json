{
    "summary": "The \"FunctionAndClassCollector\" visits Python code nodes, collecting functions and classes with or without docstrings based on a force parameter. This data is used in traversing a CST tree to generate a list of class and function names.",
    "details": [
        {
            "comment": "Class \"FunctionAndClassCollector\" is a visitor for collecting functions and classes from Python code. It checks if the function or class has a docstring, and adds it to respective lists based on `force` parameter value.",
            "location": "\"/media/root/Toshiba XG3/works/write-the/docs/src/write_the/cst/function_and_class_collector.py\":0-30",
            "content": "import libcst as cst\nfrom .utils import has_docstring\nclass FunctionAndClassCollector(cst.CSTVisitor):\n    def __init__(self, force):\n        \"\"\"\n        Initializes the FunctionAndClassCollector.\n        Args:\n          force (bool): Whether to force the collection of functions and classes even if they have docstrings.\n        \"\"\"\n        self.functions = []\n        self.classes = []\n        self.force = force\n        self.current_class = None\n    def visit_FunctionDef(self, node: cst.FunctionDef) -> None:\n        \"\"\"\n        Visits a FunctionDef node and adds it to the list of functions if it does not have a docstring or if `force` is `True`.\n        Args:\n          node (cst.FunctionDef): The FunctionDef node to visit.\n        \"\"\"\n        name = (\n            f\"{self.current_class}.{node.name.value}\"\n            if self.current_class\n            else node.name.value\n        )\n        if not has_docstring(node) or self.force:\n            self.functions.append(name)\n    def visit_ClassDef(self, node: cst.ClassDef) -> None:"
        },
        {
            "comment": "The function `FunctionAndClassCollector` visits a `ClassDef` node, adds its name to the list of classes if it doesn't have a docstring or force is True. It then calls the superclass method to continue visiting other nodes. The `get_node_names` function uses this collector to traverse a CST tree and return a list of class and function names.",
            "location": "\"/media/root/Toshiba XG3/works/write-the/docs/src/write_the/cst/function_and_class_collector.py\":31-56",
            "content": "        \"\"\"\n        Visits a ClassDef node and adds it to the list of classes if it does not have a docstring or if `force` is `True`.\n        Args:\n          node (cst.ClassDef): The ClassDef node to visit.\n        \"\"\"\n        self.current_class = node.name.value\n        if not has_docstring(node) or self.force:\n            self.classes.append(node.name.value)\n        # self.visit_ClassDef(node)  # Call the superclass method to continue the visit\n    def leave_ClassDef(self, node: cst.ClassDef) -> None:\n        self.current_class = None\ndef get_node_names(tree, force):\n    \"\"\"\n    Gets the names of functions and classes from a CST tree.\n    Args:\n      tree (cst.CSTNode): The CST tree to traverse.\n      force (bool): Whether to force the collection of functions and classes even if they have docstrings.\n    Returns:\n      list[str]: A list of function and class names.\n    \"\"\"\n    collector = FunctionAndClassCollector(force)\n    tree.visit(collector)\n    return collector.classes + collector.functions"
        }
    ]
}