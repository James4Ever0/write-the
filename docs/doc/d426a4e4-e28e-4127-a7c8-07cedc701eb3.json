{
    "summary": "The `DocstringAdder` class extends `cst.CSTTransformer`, adding or updating docstrings in a Python AST using a dictionary, and allows for overwriting existing docstrings based on conditions such as indentation level and function/class name.",
    "details": [
        {
            "comment": "This code defines a class `DocstringAdder` that extends `cst.CSTTransformer`. It adds docstrings to function definitions and classes, based on certain conditions. The `leave_FunctionDef` method adds a docstring to a function definition node, while the `visit_ClassDef` and `leave_ClassDef` methods are used to keep track of class names for adding docstrings later.",
            "location": "\"/media/root/Toshiba XG3/works/write-the/docs/src/write_the/cst/docstring_adder.py\":0-31",
            "content": "import libcst as cst\nfrom .utils import has_docstring, remove_docstring\nimport textwrap\nimport re\nclass DocstringAdder(cst.CSTTransformer):\n    def __init__(self, docstrings, force, indent=\"    \"):\n        self.docstrings = docstrings\n        self.force = force\n        self.indent = indent\n        self.current_class = None\n    def leave_FunctionDef(\n        self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n    ) -> cst.FunctionDef:\n        \"\"\"\n        Adds a docstring to a function definition.\n        Args:\n          original_node (cst.FunctionDef): The original CST node.\n          updated_node (cst.FunctionDef): The updated CST node.\n        Returns:\n          cst.FunctionDef: The updated CST node with a docstring added.\n        \"\"\"\n        return self.add_docstring(updated_node)\n    def visit_ClassDef(self, original_node: cst.ClassDef) -> None:\n        self.current_class = original_node.name.value\n    def leave_ClassDef(\n        self, original_node: cst.ClassDef, updated_node: cst.ClassDef\n    ) -> cst.ClassDef:"
        },
        {
            "comment": "Method adds docstrings to a class definition.",
            "location": "\"/media/root/Toshiba XG3/works/write-the/docs/src/write_the/cst/docstring_adder.py\":32-60",
            "content": "        \"\"\"\n        Adds a docstring to a class definition.\n        Args:\n          original_node (cst.ClassDef): The original CST node.\n          updated_node (cst.ClassDef): The updated CST node.\n        Returns:\n          cst.ClassDef: The updated CST node with a docstring added.\n        \"\"\"\n        self.current_class = None\n        updated_node = self.add_docstring(updated_node)\n        return updated_node\n    def add_docstring(self, node):\n        \"\"\"\n        Adds a docstring to a CST node.\n        Args:\n            node (cst.CSTNode): The CST node to add a docstring to.\n        Returns:\n            cst.CSTNode: The updated CST node with a docstring added.\n        \"\"\"\n        key = (\n            f\"{self.current_class}.{node.name.value}\"\n            if self.current_class\n            else node.name.value\n        )\n        docstring: str = self.docstrings.get(key, None)\n        if docstring and (self.force or not has_docstring(node)):\n            if self.force and has_docstring(node):\n                # Remove existing docstring"
        },
        {
            "comment": "This code adds or updates docstrings in a Python AST (Abstract Syntax Tree) using a dictionary to map function/class names to their respective docstrings. If the `force` parameter is True, it will overwrite existing docstrings. The `indent` parameter determines the indentation level for the new docstrings based on whether it's a class or not.",
            "location": "\"/media/root/Toshiba XG3/works/write-the/docs/src/write_the/cst/docstring_adder.py\":61-76",
            "content": "                node = remove_docstring(node)\n            escaped_docstring = re.sub(r\"(?<!\\\\)\\\\n\", \"\\\\\\\\\\\\\\\\n\", docstring)\n            dedented_docstring = textwrap.dedent(escaped_docstring)\n            indent = self.indent\n            if self.current_class:\n                indent = indent * 2\n            indented_docstring = textwrap.indent(dedented_docstring, indent)\n            new_docstring = cst.parse_statement(f'\"\"\"{indented_docstring}{indent}\"\"\"')\n            body = node.body.with_changes(body=(new_docstring, *node.body.body))\n            return node.with_changes(body=body)\n        return node\ndef add_docstrings_to_tree(tree, docstring_dict, force=False):\n    return tree.visit(DocstringAdder(docstring_dict, force=force, indent=tree.config_for_parsing.default_indent))"
        }
    ]
}